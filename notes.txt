
Questions etc:
=========

Only required attributes of message now are level & format_spec (the text).
I've thought about making name mandatory (eh). Going the other way, I've
thought about making level optional (too flexible, and easy enough to
ignore - see log.struct())

Any pet peeves from logging I may have forgotten about?

Does the method chaining technique make sense? Is it too magic? I <3 it.
You can do as many .fields()/.name()/.etc() in any order, as long as the
.action() is last.

Timing data: In a super-simple smoke test, twiggy was about 40% faster than
logging. Not rigorous.  sloccount says 220 lines.

The future
=========
Needs tests, proper docstrings, etc. obviously, but most of the long-term work is in emitters.

Emitters
++++++
Simple API now:

class Emitter(object):
    """
    Emits!

    :ivar min_level: only emit if greater than this
    :type min_level: Levels.LogLevel
    """
    def emit(self, msg):
        """emit a message.

        This is the only external API
        """
    
    def filter(self, msg):
        """return True if the message should be emitted

        I could be <some_regex>.match, perhaps
        """
    
    def format(self, msg):
        """
        :returns: the formatted message, ready for output
        :rtype: string
        """
    
    def output(self, msg, s):
        """write out the message"""
    
The filtering, formatting, and outputting should be  indepenent & composable nicely, ideally. Not really sure what the right pattern is here - I'm a little tired of mixins.

I'd like to support 'asynchronous' emitting, at some point - queueing the message and moving the write out of the critical path of user code.  Backends that talk to syslog, as well as batteries included via threading/multiprocessing.

Log4j
++++
I think I can build a decent fascimle of user-side of log4j with this:

from twiggy import log4j
log4j.getLogger('oldstyle')  -> log.name()
<etc>