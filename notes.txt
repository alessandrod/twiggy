Flubberage:
===========

* author Peter Fein
* email pfein@pobox.com
* web http://python-twiggy.googlecode.com
* hg https://python-twiggy.googlecode.com/hg/

Usage:
======
Make doctest work:
>>> import sys; sys.stderr = sys.stdout

Setup is simple
+++++++++++++++
In your main.py:

>>> import twiggy
>>> twiggy.quick_setup()

Logging Messages
++++++++++++++++

>>> from twiggy import *

Main interface is the the magic **log**:

>>> log
<twiggy.Logger.Logger object at 0x28ab368>

It works out of the box, using standard levels:

>>> log.debug('You may not care')
DEBUG:You may not care
>>> log.error('OMFG! Pants on fire!')
ERROR:OMFG! Pants on fire!

It supports format strings:

>>> log.info('I like %s', "bikes")
INFO:I like bikes

But prefers new style:

>>> log.info('I wear {0} on my {where}', 'pants', where='legs')
INFO:I wear pants on my legs

You can name your loggers:

>>> mylog = log.name('alfredo')
>>> mylog.debug('hello')
DEBUG:alfredo:hello

But the name has no relation to the object; it's just for human use:
>>> mylog is log.name('alfredo')
False

Emitting Messages
+++++++++++++++++
Emitters are loosely coupled:
>>> twiggy.emitters
{'*': <twiggy.Emitter.Emitter object at 0xc1f7d0>}

You can set a min_level on Emitters:
>>> twiggy.emitters['*'].min_level = twiggy.Levels.INFO
>>> log.debug("Help, help I'm being suppressed")
>>> log.info("I'm not quite dead yet")
INFO:I'm not quite dead yet

You can filter on regexes:
>>> twiggy.emitters['*'].filter = ".*pants.*"
>>> log.info("Got my {0} on", "pants")
INFO:Got my pants on
>>> log.info("Got my {0} on", "shirt")

Let's reset that:
>>> twiggy.emitters['*'].filter = True
>>> twiggy.emitters['*'].min_level = twiggy.Levels.DEBUG

Better output
+++++++++++++
Newlines are suppressed by default; that can be turned off per-message:

>>> log.info('user\ninput\nannoys\nus')
INFO:user\ninput\nannoys\nus

>>> log.options(suppress_newlines=False).info('we\ndeal')
INFO:we
deal

Exceptions are prefixed. Can also pass exc_info. Use '\\n' as a prefix to fold into a single line:

>>> try:
...     1/0
... except:
...     log.trace('error').warning('oh noes') # error is the default & can be omitted
WARNING:oh noes
TRACE Traceback (most recent call last):
TRACE   File "./futz.py", line 35, in <module>
TRACE     1/0
TRACE ZeroDivisionError: integer division or modulo by zero

Method Chaining
++++++++++++++++++
I like this chained style a lot.

>>> log.name('benito').info('hi there')
INFO:benito:hi there

It makes structured logging easy:

>>> log.fields(paths=42).info('Going for a walk')
INFO:paths=42:Going for a walk

Short cut.  Great for runtime statistics gathering.

>>> log.struct(paths=42, dolphins='thankful')
INFO:dolphins=thankful:paths=42:

Partial binding can be useful for webapps:

>>> per_request_log = log.fields(request_id='12345')
>>> per_request_log.fields(rows=100, user='frank').info('frobnicating database')
INFO:request_id=12345:rows=100:user=frank:frobnicating database
>>> per_request_log.fields(bytes=5678).info('sending page over tubes')
INFO:bytes=5678:request_id=12345:sending page over tubes

Chained style is awesome:

>>> log.name('donjuan').fields(pants='sexy').info("hello, {who} want to {what}?", who='ladies', what='dance')
INFO:donjuan:pants=sexy:hello, ladies want to dance?

Dynamic!
++++++++
Any functions in args/fields are called and the value substitued:

>>> import os
>>> from twiggy.lib import thread_name
>>> thread_name()
'MainThread'
>>> log.fields(pid=os.getpid).info("I'm in thread {0}", thread_name)
INFO:pid=1076:I'm in thread MainThread

This can be useful with partially-bound loggers, which let's us do some cool stuff:

>>> class ThreadTracker(object):
...     def __init__(self, obj):
...         self.__obj = obj
...         # a partially bound logger
...         self.__log = log.name("tracker").fields(obj_id=id(obj), thread=thread_name)
...         self.__log.debug("started tracking")
...     def __getattr__(self, attr):
...         self.__log.debug("accessed {0}", attr)
...         return getattr(self.__obj, attr)
...
>>> class Bunch(object):
...     pass
...
>>> foo = Bunch()
>>> foo.bar = 42
>>> tracked = ThreadTracker(foo)
DEBUG:tracker:obj_id=14063980:thread=MainThread:started tracking
>>> tracked.bar
DEBUG:tracker:obj_id=14063980:thread=MainThread:accessed bar
42
>>> import threading
>>> t=threading.Thread(target = lambda: tracked.bar * 2, name = "TheDoubler")
>>> t.start()
DEBUG:tracker:obj_id=14063980:thread=TheDoubler:accessed bar

If you really want to log a callable, repr() it or wrap it in lambda.

Optimizations
+++++++++++++
As an optimization, a min_level can be set on loggers:

>>> mylog.min_level = twiggy.Levels.INFO
>>> mylog.info("You see this")
INFO:alfredo:You see this
>>> mylog.debug("This is hidden")

They also take a filter that operates on format_spec. The use case is efficiently
shutting off specific messages in a library which is doing something stupid:

>>> mylog.filter = lambda s: "shenanigans" not in s
>>> mylog.info("Starting silliness")
INFO:alfredo:Starting silliness
>>> for i in xrange(3): # for large values of 3
...     mylog.info("I call shenanigans!")
>>> mylog.info("End silliness")
INFO:alfredo:End silliness

Questions:
==============
The only required attributes of message atm are level & format_spec (the text).
I've thought about making name mandatory (eh). Going the other way, I've
thought about making level optional (too flexible, and easy enough to
ignore - see log.struct())

Does the method chaining technique make sense? Is it too magic? I <3 it.
You can do as many .fields()/.name()/.etc() in any order, as long as the
.action() is last.

Speed
=====
Timing data: In a super-simple smoke test, twiggy was about 40% faster than
logging. Not rigorous.  sloccount says 220 lines.

The future
==============
Needs tests, proper docstrings, etc. obviously, but most of the long-term work is in emitters.

Sean, we talked about a Couchdb backend- syslog, & some form of sql* seems reasonable as well. I'd like to support 'asynchronous' emitting, at some point - queueing the message and moving the write out of the critical path of user code via multiprocessing/threading. Might be interesting to have an emitter/configuration that lets you run unittests on your log output too.

I have some thoughts about HTML output (perhaps served from a child process & streamed via AJAX?) but that's getting ahead of ourselves. ;-)

Log4j
+++++++++++++++++
I think I can build a decent fascimle of user-side of log4j with this:

from twiggy import log4j
log4j.getLogger('oldstyle')  -> log.name()
<etc>

Further Ahead of Ourself
++++++++++++++++++++++++
Lumberjack: log *parsing* should be easier, esp for casual/ad-hoc use. construct log parsers from same formats used for emitters?  snazzy

Any other pet peeves from logging I may have forgotten about?

YOUR IDEA HERE!
