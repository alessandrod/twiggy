Twiggy: a Pythonic logger

Principles
==========
- a log message that will not emit anything should be as fast as human(e)ly possible.  In general, logging should have as little impact on performance/operation as possible.
- There should be one way to do it
- 90% use case compatability layer in twiggy.log4j.  twiggy.log4j.hijack_logging(..) will install it in sys.modules s.t. `import logging` gives you log4j
- reuse from stdlib logging, esp. Handlers? 
- no hierarchy. A single logger & a list of emitters.  Logging system passes each message to emitters, who run regexes on name/entire message to decide what to do.
- NO FUNCTORS!

Usability
=========
- users shouldn't have to pass logging objects around - logging.getLogger(..) is nice this way.
- no arbitrary levels - only debug, info, warning, error, critical.  There is a disabled level that's higher than critical to shut things off entirely.
- dots are for propogation only.  You can only install emitters at top-level loggers
- logging only uses varargs & kwargs - no prepacked tuples
- partial binding gives new loggers. Main use case is sticking a job/request/session id in messages. We can do prefix formatting this way too.

Output
======
- logs should be greppable
- we'll have a master logger which receives all events (unless supressed)
- emitters do output; return True to suppress (so that events are propogated by default, ie if the user forgets an explicit return)
- if you want structured logs, you should be using kwargs. 

Errors
======
- loggers should log internal exceptions, not raise them
- if you have insufficient/wrong args for the format string, output repr'd message & args

Ideas
=====
- SOURCE should be greppable for logging.  We can write a custom fucking importer to do static analysis & "comment out" lines that will never emit (instead of having to do this @ run time)
- if you pass a callable, it will be called & the returned value subbed in the format string.  Use repr() if you want the callable itself.
- nice to have - "async" logging via thread/multiprocessing
- logging configuration is frozen before any messages are output.

Questions
=========
- how does configuration work? stdlib's logging uses ConfigParser, but this rapidly gets unwieldy.  I like configuration via code, but...
- ping Jesse Noller w/ this?
